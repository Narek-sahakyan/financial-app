<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Windows.Forms" #>
<#@ assembly name="System.Runtime.Serialization" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.Interop.8.0" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>

<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".generated.ts" #>

<#@ import namespace="Microsoft.VisualStudio.Shell.Interop" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="EnvDTE80" #>

// <autogenerated>
//   This file was generated using <#= System.IO.Path.GetFileName(Host.TemplateFile) #>.
//   Any changes made manually will be lost next time the file is regenerated.
// </autogenerated>

<#
	// get current project 
	// read project file
	IServiceProvider hostServiceProvider = (IServiceProvider)Host;
	EnvDTE.DTE dte = (EnvDTE.DTE)hostServiceProvider.GetService(typeof(EnvDTE.DTE));
	if (dte == null) {
		throw new Exception("Could not get IDE instance - try restarting Visual Studio");
	}


	EnvDTE.ProjectItem templateProjectItem = dte.Solution.FindProjectItem(Host.TemplateFile);
	EnvDTE.Project currentProject = templateProjectItem.ContainingProject;
    
ProcessRecursive(currentProject.CodeModel);
#>

module <#= GetSuggestedNamespace(templateProjectItem) #> {

    <#foreach (CodeClass cls in this._dataTypeObjects){#>
    
    export interface I<#=cls.Name#> {
        <# foreach (var item in GetConvertableProperties(cls)) { #>

            <#=item.Key#> : <#=item.Value#>;

        <#}#>
    }

    <#}#>
}

<#+
	const string TargetNamespace = "Beco.Stoffenmanager.DataTransfer.Import.FriendlyXsd";
    const string ErrorConverterInterface = "IErrorConverter";
    static readonly string DataContractAttributeFullName = typeof(System.Runtime.Serialization.DataContractAttribute).FullName;
    static readonly string DataMemberAttributeFullName = typeof(System.Runtime.Serialization.DataMemberAttribute).FullName;

    private readonly List<CodeClass> _dataTypeObjects = new List<CodeClass>();

    private IEnumerable<KeyValuePair<string, string>> GetConvertableProperties(CodeClass cls) {
        foreach (CodeProperty2 prop in cls.Members.OfType<CodeProperty2>()) {
            CodeAttribute2 dataMemberAttribute = prop.Attributes.OfType<CodeAttribute2>().FirstOrDefault(x=>x.FullName == DataMemberAttributeFullName);
            if (dataMemberAttribute == null) {
                continue;
            }

            // get name 
            string name = dataMemberAttribute.Arguments.OfType<CodeAttributeArgument>()
                                                       .Where(x=>x.Name == "Name")
                                                       .Select(x=>x.Value)
                                                       .FirstOrDefault();

            if (name != null) {
                name = name.Trim('"');
            }

            yield return new KeyValuePair<string, string>(name ?? prop.Name, ConvertType(prop));
        }
    }

    private string ConvertType(CodeProperty2 prop) {
        if (this._dataTypeObjects.Contains(prop.Type.CodeType as CodeClass)) {
            return "I" + prop.Type.CodeType.Name;
        }

        switch (prop.Type.AsFullName) {
            case "System.Int32":
            case "System.Int64":
            case "System.Int16":
            case "System.Double":
            case "System.Single":
                return "number";

            case "System.String":
                return "string";

            case "System.Boolean":
                return "boolean";
        }

        return "any";
    }

	private void ProcessRecursive(CodeModel codeModel) {
	    if (codeModel == null) {
	        return;
	    }
		 

		foreach(EnvDTE.CodeElement element in codeModel.CodeElements)
		{
			ProcessRecursive(element);
		}
    }

    private void ProcessRecursive(CodeElement codeElement) {
        if (codeElement.Kind == EnvDTE.vsCMElement.vsCMElementClass) {
			var myClass = (EnvDTE.CodeClass)codeElement;
			ProcessClass(myClass);
		}

		// recursively process namespace
		if (codeElement.Kind == EnvDTE.vsCMElement.vsCMElementNamespace) {
			var myNs = (EnvDTE.CodeNamespace)codeElement;

			foreach (CodeElement childCodeElement in myNs.Members) {
				ProcessRecursive(childCodeElement);
			}
		}
    }

    private void ProcessClass(CodeClass cls) {
		// process only 'IEncryptable' classes
        if (!cls.Attributes.OfType<CodeAttribute>().Any(x=>x.FullName == DataContractAttributeFullName)) {
            return;
        }

		this._dataTypeObjects.Add(cls);
    }

    

    private string GetSuggestedNamespace(ProjectItem item) {
        string ns = item.Properties.Item("CustomToolNamespace").Value.ToString();
        if (String.IsNullOrEmpty(ns)) {
            return "INVALID.PROVIDE.CUSTOM.TOOL.NAMESPACE.IN.THIS.ITEM.SETTINGS";
        }

        return ns;
    }

    private static bool IsDirectTransformationSupported(CodeProperty property) {
        return property.Type.AsFullName == "System.String";
    }
#>