<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Windows.Forms" #>
<#@ assembly name="System.Runtime.Serialization" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.Interop.8.0" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>

<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".generated.d.ts" #>

<#@ import namespace="Microsoft.VisualStudio.Shell.Interop" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="EnvDTE80" #>
<#@ import namespace="System.Text.RegularExpressions" #>

// <autogenerated>
//   This file was generated using <#= System.IO.Path.GetFileName(this.Host.TemplateFile) #>.
//   Any changes made manually will be lost next time the file is regenerated.
// </autogenerated>

<#
	// get current project 
	// read project file
	IServiceProvider hostServiceProvider = (IServiceProvider) this.Host;
	EnvDTE.DTE dte = (EnvDTE.DTE)hostServiceProvider.GetService(typeof(EnvDTE.DTE));
	if (dte == null) {
		throw new Exception("Could not get IDE instance - try restarting Visual Studio");
	}


    EnvDTE.ProjectItem templateProjectItem = dte.Solution.FindProjectItem(this.Host.TemplateFile);
    foreach (EnvDTE.Project currentProject in dte.Solution.OfType<EnvDTE.Project>()) {
        this.ProcessRecursive(currentProject.CodeModel);
    }
#>
    

declare module <#=
    this.GetSuggestedNamespace(templateProjectItem) #> {

    export interface IObject {
        // just an empty interface which makes programming the *.tt easier
    }

    <#foreach (CodeClass cls in this._dataTypeObjects){#>
    
    export interface I<#=cls.Name#> extends <#=GetExtension(cls)#> {
        <# foreach (var item in this.GetConvertableProperties(cls)) { #>

            <#=item.Key#> : <#=item.Value#>;

        <#}#>
    }

    <#}#>
}


<#+
    static readonly string DataContractAttributeFullName = typeof(System.Runtime.Serialization.DataContractAttribute).FullName;
    static readonly string DataMemberAttributeFullName = typeof(System.Runtime.Serialization.DataMemberAttribute).FullName;

    private readonly List<CodeClass> _dataTypeObjects = new List<CodeClass>();
    private readonly List<CodeEnum> _enumObjects = new List<CodeEnum>();

    private static string GetExtension(CodeClass cls) {
        var baseCls = cls.Bases.OfType<CodeClass>().FirstOrDefault();

        if (baseCls != null) {
            return "I" + baseCls.Name;
        }

        return "IObject";
    }

    private IEnumerable<KeyValuePair<string, string>> GetConvertableProperties(CodeClass cls) {
        foreach (CodeProperty2 prop in cls.Members.OfType<CodeProperty2>()) {
            CodeAttribute2 dataMemberAttribute = prop.Attributes.OfType<CodeAttribute2>().FirstOrDefault(x=>x.FullName == DataMemberAttributeFullName);
            if (dataMemberAttribute == null) {
                continue;
            }

            // get name 
            string name = dataMemberAttribute.Arguments.OfType<CodeAttributeArgument>()
                                                       .Where(x=>x.Name == "Name")
                                                       .Select(x=>x.Value)
                                                       .FirstOrDefault();

            if (name != null) {
                name = name.Trim('"');
            }

            yield return new KeyValuePair<string, string>(name ?? ToCamelCase(prop.Name), this.ConvertType(prop));
        }
    }

    private string ConvertType(CodeProperty2 prop) {
        CodeType targetType;
        bool isArray = (prop.Type.TypeKind == vsCMTypeRef.vsCMTypeRefArray);

        if (isArray) {
            CodeTypeRef arr = prop.Type.ElementType;

            targetType = arr.CodeType;
        } else {
            targetType = prop.Type.CodeType;

            if (targetType.FullName.IndexOf("IEnumerable", System.StringComparison.Ordinal) != -1) {
                string type = Regex.Replace(targetType.FullName,
                    @"System.Collections.Generic.IEnumerable<([A-z0-9.]+)\.([A-z0-9]+)>", "$2");
                return ParseType(type, true) + "[] /*" + targetType.FullName + "*/ ";
            }
        }

        if (this._dataTypeObjects.Contains(targetType as CodeClass)) {
            return "I" + targetType.Name + (isArray ? "[]" : String.Empty) + " /* " + targetType.FullName + "*/ ";
        }

		if (this._enumObjects.Contains(targetType as CodeEnum)) {
			return targetType.Name;
		}
        
        return ParseType(targetType.FullName, false);
    }

    private static string ParseType(string typeName, bool returnInterface) {
        // remove any system prefix
        typeName = typeName.StartsWith("System.", StringComparison.OrdinalIgnoreCase)
                        ? typeName.Substring("System.".Length) : typeName;

        switch (typeName) {
            case "Int32":
            case "Int64":
            case "Int16":
            case "Double":
            case "Single":
            case "Decimal":
                return "number";

            case "String":
                return "string";

            case "Boolean":
                return "boolean";
        }

        return returnInterface ? "I"+ typeName : "any";
    }

	private void ProcessRecursive(CodeModel codeModel) {
	    if (codeModel == null) {
	        return;
	    }

		foreach(EnvDTE.CodeElement element in codeModel.CodeElements)
		{
		    this.ProcessRecursive(element);
		}
    }

    private void ProcessRecursive(CodeElement codeElement) {
        // process enum
        if (codeElement.Kind == EnvDTE.vsCMElement.vsCMElementEnum) {
			var myEnum = (EnvDTE.CodeEnum)codeElement;
            this.ProcessEnum(myEnum);
		}
        // process class
        if (codeElement.Kind == EnvDTE.vsCMElement.vsCMElementClass) {
			var myClass = (EnvDTE.CodeClass)codeElement;
            this.ProcessClass(myClass);
		}

		// recursively process namespace
		if (codeElement.Kind == EnvDTE.vsCMElement.vsCMElementNamespace) {
			var myNs = (EnvDTE.CodeNamespace)codeElement;

			foreach (CodeElement childCodeElement in myNs.Members) {
			    this.ProcessRecursive(childCodeElement);
			}
		}
    }

    private void ProcessClass(CodeClass cls) {
		// process only 'IEncryptable' classes
        if (cls.Attributes.OfType<CodeAttribute>().All(x => x.FullName != DataContractAttributeFullName)) {
            return;
        }

		this._dataTypeObjects.Add(cls);
    }

    private void ProcessEnum(CodeEnum e) {
		// process only 'IEncryptable' classes
        if (e.Attributes.OfType<CodeAttribute>().All(x => x.FullName != DataContractAttributeFullName)) {
            return;
        }

		this._enumObjects.Add(e);
    }


    private string GetSuggestedNamespace(ProjectItem item) {
        string ns = item.Properties.Item("CustomToolNamespace").Value.ToString();
        if (String.IsNullOrEmpty(ns)) {
            return "INVALID.PROVIDE.CUSTOM.TOOL.NAMESPACE.IN.THIS.ITEM.SETTINGS";
        }

        return ns;
    }

    private static bool IsDirectTransformationSupported(CodeProperty property) {
        return property.Type.AsFullName == "System.String";
    }

    private static string ToCamelCase(string s) {
            if (string.IsNullOrEmpty(s))
                return s;

            if (!char.IsUpper(s[0]))
                return s;

            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < s.Length; i++)
            {
                bool hasNext = (i + 1 < s.Length);
                if ((i == 0 || !hasNext) || char.IsUpper(s[i + 1]))
                {
                    char lowerCase;
#if !(NETFX_CORE || PORTABLE)
                    lowerCase = char.ToLower(s[i], System.Globalization.CultureInfo.InvariantCulture);
#else
                    lowerCase = char.ToLower(s[i]);
#endif

                    sb.Append(lowerCase);
                }
                else
                {
                    sb.Append(s.Substring(i));
                    break;
                }
            }

            return sb.ToString();
        }
#>