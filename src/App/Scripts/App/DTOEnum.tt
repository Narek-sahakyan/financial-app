<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Windows.Forms" #>
<#@ assembly name="System.Runtime.Serialization" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.Interop.8.0" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>

<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".generated.ts" #>

<#@ import namespace="Microsoft.VisualStudio.Shell.Interop" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="EnvDTE80" #>

// <autogenerated>
//   This file was generated using <#= System.IO.Path.GetFileName(Host.TemplateFile) #>.
//   Any changes made manually will be lost next time the file is regenerated.
// </autogenerated>

<#
	// get current project 
	// read project file
	IServiceProvider hostServiceProvider = (IServiceProvider)Host;
	EnvDTE.DTE dte = (EnvDTE.DTE)hostServiceProvider.GetService(typeof(EnvDTE.DTE));
	if (dte == null) {
		throw new Exception("Could not get IDE instance - try restarting Visual Studio");
	}


	EnvDTE.ProjectItem templateProjectItem = dte.Solution.FindProjectItem(Host.TemplateFile);
	EnvDTE.Project currentProject = templateProjectItem.ContainingProject;
    
    ProcessRecursive(currentProject.CodeModel);
#>

module <#= GetSuggestedNamespace(templateProjectItem) #> {



<#foreach (CodeEnum e in this._enumObjects){#>
    
    export enum <#=e.Name#> {
        <# foreach (CodeVariable item in e.Members) { #>

            <#=item.Name#> <#=item.InitExpression != null ? " = " + item.InitExpression : ""#>,

        <#}#>
    }

    <#}#>
}

<#+
    static readonly string DataContractAttributeFullName = typeof(System.Runtime.Serialization.DataContractAttribute).FullName;
    static readonly string DataMemberAttributeFullName = typeof(System.Runtime.Serialization.DataMemberAttribute).FullName;

    private readonly List<CodeClass> _dataTypeObjects = new List<CodeClass>();
    private readonly List<CodeEnum> _enumObjects = new List<CodeEnum>();

    private IEnumerable<KeyValuePair<string, string>> GetConvertableProperties(CodeClass cls) {
        foreach (CodeProperty2 prop in cls.Members.OfType<CodeProperty2>()) {
            CodeAttribute2 dataMemberAttribute = prop.Attributes.OfType<CodeAttribute2>().FirstOrDefault(x=>x.FullName == DataMemberAttributeFullName);
            if (dataMemberAttribute == null) {
                continue;
            }

            // get name 
            string name = dataMemberAttribute.Arguments.OfType<CodeAttributeArgument>()
                                                       .Where(x=>x.Name == "Name")
                                                       .Select(x=>x.Value)
                                                       .FirstOrDefault();

            if (name != null) {
                name = name.Trim('"');
            }

            yield return new KeyValuePair<string, string>(name ?? prop.Name, ConvertType(prop));
        }
    }

    private string ConvertType(CodeProperty2 prop) {
        CodeType targetType;
        bool isArray = false;

        if (isArray = (prop.Type.TypeKind == vsCMTypeRef.vsCMTypeRefArray)) {
            CodeTypeRef arr = prop.Type.ElementType;

            targetType = arr.CodeType;
        } else {
            targetType = prop.Type.CodeType;
        }

        if (this._dataTypeObjects.Contains(targetType as CodeClass)) {
            return "I" + targetType.Name + (isArray ? "[]" : String.Empty);
        }

		if (this._enumObjects.Contains(targetType as CodeEnum)) {
			return targetType.Name;
		}

        switch (targetType.FullName) {
            case "System.Int32":
            case "System.Int64":
            case "System.Int16":
            case "System.Double":
            case "System.Single":
                return "number";

            case "System.String":
                return "string";

            case "System.Boolean":
                return "boolean";
        }

        return "any";
    }

	private void ProcessRecursive(CodeModel codeModel) {
	    if (codeModel == null) {
	        return;
	    }

		foreach(EnvDTE.CodeElement element in codeModel.CodeElements)
		{
			ProcessRecursive(element);
		}
    }

    private void ProcessRecursive(CodeElement codeElement) {
        // process enum
        if (codeElement.Kind == EnvDTE.vsCMElement.vsCMElementEnum) {
			var myEnum = (EnvDTE.CodeEnum)codeElement;
			ProcessEnum(myEnum);
		}
        // process class
        if (codeElement.Kind == EnvDTE.vsCMElement.vsCMElementClass) {
			var myClass = (EnvDTE.CodeClass)codeElement;
			ProcessClass(myClass);
		}

		// recursively process namespace
		if (codeElement.Kind == EnvDTE.vsCMElement.vsCMElementNamespace) {
			var myNs = (EnvDTE.CodeNamespace)codeElement;

			foreach (CodeElement childCodeElement in myNs.Members) {
				ProcessRecursive(childCodeElement);
			}
		}
    }

    private void ProcessClass(CodeClass cls) {
		// process only 'IEncryptable' classes
        if (!cls.Attributes.OfType<CodeAttribute>().Any(x=>x.FullName == DataContractAttributeFullName)) {
            return;
        }

		this._dataTypeObjects.Add(cls);
    }

    private void ProcessEnum(CodeEnum e) {
		// process only 'IEncryptable' classes
        if (!e.Attributes.OfType<CodeAttribute>().Any(x=>x.FullName == DataContractAttributeFullName)) {
            return;
        }

		this._enumObjects.Add(e);
    }


    private string GetSuggestedNamespace(ProjectItem item) {
        string ns = item.Properties.Item("CustomToolNamespace").Value.ToString();
        if (String.IsNullOrEmpty(ns)) {
            return "INVALID.PROVIDE.CUSTOM.TOOL.NAMESPACE.IN.THIS.ITEM.SETTINGS";
        }

        return ns;
    }

    private static bool IsDirectTransformationSupported(CodeProperty property) {
        return property.Type.AsFullName == "System.String";
    }
#>