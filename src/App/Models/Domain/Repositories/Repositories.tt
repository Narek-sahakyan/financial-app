<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Windows.Forms" #>
<#@ assembly name="System.Runtime.Serialization" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.Interop.8.0" #>
<#@ assembly name="Microsoft.CSharp" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>

<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Dynamic" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".generated.cs" #>

<#@ import namespace="Microsoft.VisualStudio.Shell.Interop" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="EnvDTE80" #>

// <autogenerated>
//   This file was generated using <#= System.IO.Path.GetFileName(Host.TemplateFile) #>.
//   Any changes made manually will be lost next time the file is regenerated.
// </autogenerated>

<#
	// get current project 
	// read project file
	IServiceProvider hostServiceProvider = (IServiceProvider)Host;
	EnvDTE.DTE dte = (EnvDTE.DTE)hostServiceProvider.GetService(typeof(EnvDTE.DTE));
	if (dte == null) {
		throw new Exception("Could not get IDE instance - try restarting Visual Studio");
	}


	EnvDTE.ProjectItem templateProjectItem = dte.Solution.FindProjectItem(Host.TemplateFile);
	EnvDTE.Project currentProject = templateProjectItem.ContainingProject;
    
ProcessRecursive(currentProject.CodeModel);
#>

namespace <#= GetSuggestedNamespace(templateProjectItem) #> {
    using System.Data.Entity;
    using System.Linq;
    using System.Threading;
    using System.Threading.Tasks;

    <#foreach (CodeClass cls in this._dataTypeObjects){#>
    
    public sealed partial class <#=cls.Name#>Repository {
        private readonly DbContext _dbContext;
        private readonly DbSet<<#=cls.FullName#>> _entitySet;

        public <#=cls.Name#>Repository(DbContext dbContext) {
            this._dbContext = dbContext;
            this._entitySet = dbContext.Set<<#=cls.FullName#>>();
        }

        [CanBeNull]
        public <#=cls.FullName#> FindById(int id) {
            return this._entitySet.FirstOrDefault(x => x.Id == id);
        }

        [CanBeNull]
        public Task<<#=cls.FullName#>> FindByIdAsync(int id) {
            return this._entitySet.FirstOrDefaultAsync(x => x.Id == id);
        }

        [NotNull]
        public IQueryable<<#=cls.FullName#>> GetAll() {
            return this._entitySet;
        }

        <#foreach (dynamic prop in GetCustomQueryProperties(cls)) {#>

        [<#=prop.IsMultiple?"NotNull":"CanBeNull"#>]
        public <#=prop.ReturnType#> <#=prop.MemberName#>(<#=prop.PropertyType#> <#=CamelCase(prop.Name)#>) {
            return this._entitySet.<#=prop.QueryMethod#>(x => x.<#=prop.PropertyName#>.Id == <#=CamelCase(prop.Name)#>.Id);
        }

        [<#=prop.IsMultiple?"NotNull":"CanBeNull"#>]
        public <#=prop.ReturnType#> <#=prop.MemberName#>(int <#=CamelCase(prop.Name)#>Id) {
            return this._entitySet.<#=prop.QueryMethod#>(x => x.<#=prop.PropertyName#>.Id == <#=CamelCase(prop.Name)#>Id);
        }

        <#if(!prop.IsMultiple){#>

        [CanBeNull]
        public Task<<#=prop.ReturnType#>> <#=prop.MemberName#>Async(<#=prop.PropertyType#> <#=CamelCase(prop.Name)#>) {
            return this._entitySet.<#=prop.QueryMethod#>Async(x => x.<#=prop.PropertyName#>.Id == <#=CamelCase(prop.Name)#>.Id);
        }

        [CanBeNull]
        public Task<<#=prop.ReturnType#>> <#=prop.MemberName#>Async(int <#=CamelCase(prop.Name)#>Id) {
            return this._entitySet.<#=prop.QueryMethod#>Async(x => x.<#=prop.PropertyName#>.Id == <#=CamelCase(prop.Name)#>Id);
        }

        <#}#>
        <#}#>


        public void Add(<#=cls.FullName#> item) {
            this._entitySet.Add(item);
        }

		public void Delete(<#=cls.FullName#> item) {
			if (item != null) {
				this._entitySet.Remove(item);
			}
		}

		public void DeleteById(int id) {
			<#=cls.FullName#> item = this.FindById(id);
			if (item != null) {
				this._entitySet.Remove(item);
			}
		}

        public int SaveChanges() {
            return this._dbContext.SaveChanges();
        }

        public Task SaveChangesAsync() {
            return this._dbContext.SaveChangesAsync();
        }
    }

    <#}#>
}

<#+
    static readonly string GenerateRepositoryAttributeFullName = "App.Models.Domain.Repositories.GenerateRepositoryAttribute";
    static readonly string GenerateRepositoryQueryAttributeFullName = "App.Models.Domain.Repositories.GenerateRepositoryQueryAttribute";

    private readonly List<CodeClass> _dataTypeObjects = new List<CodeClass>();

    private IEnumerable<dynamic> GetCustomQueryProperties(CodeClass cls) {
        foreach (CodeProperty2 prop in cls.Members.OfType<CodeProperty2>()) {
            CodeAttribute2 dataMemberAttribute = prop.Attributes.OfType<CodeAttribute2>().FirstOrDefault(x=>x.FullName == GenerateRepositoryQueryAttributeFullName);
            if (dataMemberAttribute == null) {
                continue;
            }

            // get name 
            string name = dataMemberAttribute.Arguments.OfType<CodeAttributeArgument>()
                                                       .Where(x=>x.Name == "SuggestedName")
                                                       .Select(x=>x.Value)
                                                       .FirstOrDefault() ?? prop.Name;

            bool isMultiple= (dataMemberAttribute.Arguments.OfType<CodeAttributeArgument>()
                                                       .Where(x=>x.Name == "IsMultiple")
                                                       .Select(x=>x.Value)
                                                       .FirstOrDefault() ?? "false") == "true";

            dynamic result = new ExpandoObject();

            result.Name= name;
            result.MemberName = isMultiple ? "GetBy" + name : "FindBy" + name;
            result.ReturnType= isMultiple ? "IQueryable<" + cls.FullName + ">" : cls.FullName;
            result.QueryMethod = isMultiple ? "Where" : "FirstOrDefault";
            result.PropertyType = prop.Type.AsFullName;
            result.PropertyName = prop.Name;
            result.IsMultiple = isMultiple;

            yield return result;
        }
    }

    private string CamelCase(string name) {
        string subStr= name.Substring(1);
        return Char.ToLower(name[0]) + subStr;
    }

  	private void ProcessRecursive(CodeModel codeModel) {
	    if (codeModel == null) {
	        return;
	    }
		 
		foreach(EnvDTE.CodeElement element in codeModel.CodeElements)
		{
			ProcessRecursive(element);
		}
    }

    private void ProcessRecursive(CodeElement codeElement) {
        if (codeElement.Kind == EnvDTE.vsCMElement.vsCMElementClass) {
			var myClass = (EnvDTE.CodeClass)codeElement;
			ProcessClass(myClass);
		}

		// recursively process namespace
		if (codeElement.Kind == EnvDTE.vsCMElement.vsCMElementNamespace) {
			var myNs = (EnvDTE.CodeNamespace)codeElement;

			foreach (CodeElement childCodeElement in myNs.Members) {
				ProcessRecursive(childCodeElement);
			}
		}
    }

    private void ProcessClass(CodeClass cls) {
		// process only 'IEncryptable' classes
        if (!cls.Attributes.OfType<CodeAttribute>().Any(x=>x.FullName == GenerateRepositoryAttributeFullName)) {
            return;
        }

		this._dataTypeObjects.Add(cls);
    }

    private string GetSuggestedNamespace(ProjectItem item) {
        string ns = item.Properties.Item("CustomToolNamespace").Value.ToString();
        if (String.IsNullOrEmpty(ns)) {
            return "INVALID.PROVIDE.CUSTOM.TOOL.NAMESPACE.IN.THIS.ITEM.SETTINGS";
        }

        return ns;
    }

    private static bool IsDirectTransformationSupported(CodeProperty property) {
        return property.Type.AsFullName == "System.String";
    }
#>